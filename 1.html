<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="static/js/jquery-3.3.1.js"></script>
    <style>
    body{
            width: 1024px;
            margin: auto;
        }
    .nav{
        width: 100%;
        height: 40px;
        line-height: 40px;
        background: black;
    }
    .nav>div{
        float: left;
        font-size: 18px;
        padding: 0 18px;
    }
    .nav>div>a{
        color: #fff;
    }
    .n1{
        width: 100%;
        margin-top: 40px;
        font-size: 20px;
    }
    .n1>img{
        width: 60%;
        float: left;
    }
    #news,#back,#publ,#chal,#team,#resu,#reso,#ackn{
        width: 100%;
        margin-top: 40px;
    }
    #news>p,#back>p,#publ>p,#chal>p,#team>p,#resu>p,#reso>p,#ackn>p{
        font-size: 24px;
        line-height: 30px;
    }
    li{
        font-size: 18px;
    }
    .db{
        text-align: center;
        width: 100%;
    }
    a{
        text-decoration:none;
        color: red;
    }
    button{
        border: 0;
        background: #fff;
        font-size: 22px;
    }
    </style>
</head>
<body>
<div class="">
    <h1 id="n">Characterization and Modeling of Error Resilience in HPC Applications</h1>
    <div class="nav">
        <div><a href="#news">News</a></div>
        <div><a href="#back">Background</a></div>
        <div><a href="#publ">Publications</a></div>
        <div><a href="#chal">Challenge</a></div>
        <div><a href="#team">Team</a></div>
        <div><a href="#resu">Results</a></div>
        <div><a href="#reso">Resources</a></div>
        <div><a href="#ackn">Acknowledgement</a></div>
    </div>
    <div class="n1">
        <img src="static/image/0.png" alt="">
        <span>The continued growth of large-scale high performance computing (HPC) systems is fueled by the two trends: continued integration of additional functionality onto system nodes, and the increased number of nodes (and components) in the systems. As a result, these large-scale systems are jeopardized by potentially increasing faults in hardware and software. Transient faults caused by high energy particle strikes, wear-out, etc. are becoming a critical contributor to in-field system failures. Without protected by efficient and effective fault tolerance mechanisms, HPC applications can generate incorrect execution outcome and even crash in presence of transient faults. This can lead to a huge financial loss or loss of lives in some safety-critical HPC applications. As high-performance computing systems scale in size and computational power, transient faults are becoming a critical contributor to failures in HPC applications.</span>
        <br>
        <br>
        <span>There are many HPC applications that are safety-critical. These safety-critical applications cannot accept any form of failure that can lead to incorrect execution outcome to these applications. As an example of such safety-critical applications, the aircraft aviation application manages aircraft operations in real-time. Transient faults can cause a failure to aircraft aviation and this can further cause substantial safety risks such as aircraft crashes. Same aviation applications are also launched in spacecraft control systems and autonomous vehicles control systems. A crash in such aviation applications can take away lives and also cause significant financial loss. Another example of safety-critical applications could be the banking and stock trading applications. Banking and stock trading applications are usually run on a large-scale cluster to process a large amount of financial data in real-time. A failure because of transient faults to these applications can lead to a loss of millions of dollars. Note that all the proposed two examples are real-world examples. </span>
    </div>
    <div id="news">
        <p>News</p>
        <ul>
            <li>Anzheng is going to present his thesis work in IPDPS PhD Forum. Good luck!</li>
            <li>Anzheng received the IEEE TCPP travel award to attend IPDPS’19. Thank IEEE TCPP program.</li>
            <li>A paper is accepted by IPDPS’19. Congratulations!</li>
            <li>Our work published in SC’18 is highlighted by HPCwire in its “What’s new in HPC research”</li>
            <li>A paper is accepted by SC’18. Congratulations!</li>
            <li>A poster is accepted by SC’16 and the poster is nominated as Best Poster Finalist</li>
        </ul>
    </div>
    <button><a href="#n">↑ Top</a></button>
    <div id=back>
        <p>Background</p>
        <ul>
            <li>
                <p>Fault Model</p>
                <ul>
                    <li>
                        <p>Transient Faults</p>
                        <img src="static/image/1.png" alt="">
                    </li>
                    <li>We use random fault injection to mimic the effect of real soft errors in the application</li>
                    <li>
                        <p>When an error is injected, we define three possible error manifestations</p>
                        <ul>
                            <li>Success</li>
                            <li>SDC (Silent Data Corruption)</li>
                            <li>Interruption</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <p>Fault Masking</p>
                <ul>
                    <li>Fault masking can happen at the application level and hardware level</li>
                    <li>The application level fault masking happens because of application inherent semantics and program constructs</li>
                    <li>The hardware level fault masking happens because a fault does not corrupt the precise semantics of hardware</li>
                    <li>The focus of our fault tolerance modeling is the application level fault masking</li>
                    <li>Particularly, we examining numerous fault masking events at the application-level</li>
                    <li>To count the number of fault masking events that happens to individual data objects</li>
                    <li>To characterize error resilience by summarizing the reason that leads to fault masking events</li>
                </ul>
            </li>
        </ul>
    </div>
    <button><a href="#n">↑ Top</a></button>
    <div id="publ">
        <p>Publications</p>
        <ul>
            <li><a href="https://github.com/PASAUCMerced/MOARD">Luanzheng Guo and Dong Li. MOARD:</a> Modeling Application Resilience to Transient Faults on Data Objects. IEEE International Parallel & Distributed Processing Symposium (IPDPS’19), 5/20/2019, Rio.(PDF)</li>
            <li><a href="https://github.com/PASAUCMerced/MOARD">Luanzheng Guo</a>, Dong Li, Ignacio Laguna, and Martin Schulz. FlipTracker: Understanding Natural Error Resilience in HPC Applications. ACM/IEEE International Conference for High Performance Computing, Networking, Storage and Analysis (SC’18), 11/13/2018, Dallas. (PDF)</li>
            <li>Luanzheng Guo, Dong Li, Ignacio Laguna. PARIS: Predicting Application Resilience Using Machine Learning. arXiv preprint, arXiv:1812.02944, 2018.</li>
            <li><a href="https://github.com/PASAUCMerced/MOARD">Luanzheng Guo</a>, Ignacio Laguna, Dong Li. Poster: Which Fault Injection Tool Should We Use for GPU programs? LLNL Summer Poster Symposium, 8/2018, Livermore. .(PDF)</li>
            <li><a href="https://github.com/PASAUCMerced/MOARD">Luanzheng Guo</a>, Ignacio Laguna, Dong Li. Poster: Understanding the Resilience of Fundamental Data Types. LLNL Summer Poster Symposium, 8/2017, Livermore. .(PDF)</li>
            <li><a href="https://github.com/PASAUCMerced/MOARD">Luanzheng Guo</a>, Jing Liang, and Dong Li. Poster: Understanding Ineffectiveness of Application-Level Fault Injection. Poster in ACM/IEEE International Conference for High Performance Computing, Networking, Storage and Analysis (SC’16), 11/15/2016. Best Poster Finalist .(PDF)</li>
        </ul>
    </div>
    <button><a href="#n">↑ Top</a></button>
    <div id="chal">
        <p>Challenges</p>
        <ul>
            <li>
                <p>Previous studies have shown many applications that have natural resilience</p>
                <ul>
                    <li>Examples of such applications are algebraic multi-grid solvers (AMG), Conjugate Gradient (CG) solvers, Monte Carlo simulations, and machine learning algorithms, such as clustering and deep-learning neural networks</li>
                </ul>
            </li>
            <li>Previous work attribute the natural resilience to statistical and iterative structures of application</li>
            <li>What is the fundamental reason that these application have natural resilience?</li>
            <li>
                <p>Many common application-level fault tolerance mechanisms focus on data objects such as Algorithm-Based Fault Tolerance (ABFT)</p>
                <ul>
                    <li>The current common practice Random Fault Injection (RFI) cannot quantify application resilience on certain data objects because of its randomness</li>
                    <li>RFI lacks data semantics and information on how and where errors are tolerated</li>
                </ul>
            </li>
        </ul>
    </div>
    <button><a href="#n">↑ Top</a></button>
    <div id="team">
        <p>Team</p>
        <span>To solve the problem, we have the following team members:</span>
        <ul>
            <li>Luanzheng Guo, UC Merced</li>
            <li>Dong Li, UC Merced</li>
            <li>Ignacio Laguna, LLNL</li>
            <li>Martin Schulz, TUM</li>
        </ul>
    </div>
    <button><a href="#n">↑ Top</a></button>
    <div id="resu">
        <ul>
            <li>
                Inefficiency of Random Fault Injection
                <img src="static/image/2.png" alt="">
                <img src="static/image/3.png" alt="">
                <img src="static/image/4.png" alt="">
                <img src="static/image/5.png" alt="">
                <img src="static/image/6.png" alt="">
                <ul>
                    <li>
                        Observation 1:
                        <ul>
                            <li>For BT and SP, the fault injection results vary across input problem sizes. There is more than 25% variance.</li>
                        </ul>
                    </li>
                    <li>
                        Observation 2:
                        <ul>
                            <li>The fault injection result for CG and MG vary across different numbers of fault injection tests, while the fault injection results for other benchmarks are relatively stable.</li>
                        </ul>
                    </li>
                    <li>
                        Observation 3:
                        <ul>
                            <li>Based on the results of 1000 fault injection tests, we find CG is more reliable than MG. But based on the results of 2000, we make an  opposite conclusion.</li>
                        </ul>
                    </li>
                    <li>
                        Observations
                        <ul>
                            <li>The fault injection results of some applications are sensitive to the number of fault injection tests, while the fault injection results of some</li>
                            <li>The application resilience depends on the input problem size</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                FlipTracker   
                <ul>
                    <li>
                        Resilience computation patterns
                        <ul>
                            <li>
                                Dead Corrupted Locations (DCL): In this pattern, corrupted locations are not used anymore
                                <img src="static/image/7.png" alt="">
                            </li>
                            <li>
                                Repeated Additions (RA): 
                                <br>
                                In this pattern, the value of a corrupted location is repeatedly added by other correct values
                            </li>
                            <li>
                                <br>
                                <img src="static/image/8.png" alt="">
                            </li>
                            <li>
                                Conditional Statements, Shifting, Data Truncation, Data Overwriting
                            </li>
                        </ul>
                    </li>
                    <li>
                        Case studies
                        <ul>
                            <li>
                                Use case 1: Resilience-Aware Application Design
                                <ul>
                                    <li>We apply resilience patterns to the CG benchmark, aiming to improve its resilience</li>
                                    <li>The goal of this use case is to show that resilience computation patterns can guide application designs towards natural resilience</li>
                                    <li>
                                        We successfully apply three patterns, dead corrupted locations (DCL), data overwriting, and truncation, to the CG benchmark
                                        <img src="static/image/9.png" alt="">
                                        <img src="static/image/10.png" alt="">
                                        <img src="static/image/11.png" alt="">
                                    </li>
                                </ul>
                            </li>
                            <li>
                                Use case 2: Predicting Application Resilience
                                <ul>
                                    <li>We build a regression model to predict the success of the error manifestation using resilience patterns</li>
                                    <li>
                                        <br>
                                        <img src="static/image/12.png" alt="">
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li> MOARD</li>
            <li>
                To quantify application resilience to transient faults on a data object, we introduce a metric, aDVF
                <ul>
                    <li>
                        The key is to quantify how often error masking happens to data objects. The definition of aDVF:
                        <img src="static/image/13.png" alt="">
                    </li>
                    <li>
                        Model Validation
                        <img src="static/image/14.png" alt="">
                        <ul>
                            <li>
                                Observation:
                                <ul><li>aDVF and exhaustive fault injection rank the data objects in the same order</li></ul>
                            </li>
                            <li>
                                Conclusion:
                                <ul><li>aDVF correctly reasons application resilience to transient faults on data objects</li></ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        Comparing aDVF Calculation with RFI 
                        <img src="static/image/15.png" alt=""> 
                        <ul>
                            <li>The RFI results with the margin of error (the confidence level 95%) and aDVF results. The results are for three data objects (m x, m y, and m z) from LULESH</li>
                            <li>The calculation of aDVF is deterministic while the results of RFI is sensitive to the number of fault injection tests</li>
                            <li>
                                Conclusion:
                                <ul><li>We can deterministically rank data objects in terms of application resilience to transient faults on the data objects by counting aDVF</li></ul>
                            </li>
                        </ul>  
                    </li>
                    <li>
                        Use Case 1: Studying xe in Particle Filter
                        <img src="static/image/16.png" alt="">
                        <ul>
                            <li>
                                Observation:
                                <ul><li>Using ABFT does not improve much application resilience on the data object xe</li></ul>
                            </li>
                            <li>
                                Conclusions:
                                <ul>
                                    <li>ABFT is not needed for xe</li>
                                    <li>aDVF can direct error tolerance designs</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </div>
    <button><a href="#n">↑ Top</a></button>
    <div id="reso">
        <p>Resources</p>
        <span>Below we provide several useful resources with additional information about the experiment:</span>
        <ul><li><a href="https://github.com/PASAUCMerced/MOARD">MOARD</a></li></ul>
    </div>
    <button><a href="#n">↑ Top</a></button>
    <div id="ackn">
        <p>Acknowledgement</p>
        <span>This work is performed under the auspices of the U.S. Department of Energy by Lawrence Livermore National Laboratory under contract DEAC52-07NA27344 and subcontract B629135. This work is partially supported by U.S. National Science Foundation (CNS-1617967, CCF-1553645 and CCF- 1718194). </span>
    </div>
    <button><a href="#n">↑ Top</a></button>
    <br><br><br>
    <hr>
    <div class="db">
        Copyright@ 2015-2019 UC Merced and LLNL
        <br>
        Last updated: <span class="time"></span>
        <br><br><br>
    </div>
</div>    
</body>
<script>
$(function() {
var myDate = new Date;
var data=myDate.toLocaleString();
$(".time").html(data)
})
</script>
</html>